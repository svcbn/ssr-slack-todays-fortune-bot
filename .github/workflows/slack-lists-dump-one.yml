name: Slack Lists - Infer select option IDs (debug)

on:
  workflow_dispatch:
    inputs:
      list_id:
        description: "List ID (e.g., F0A8F387LCS)"
        required: true
      limit:
        description: "How many items to scan (1-50)"
        required: false
        default: "30"

jobs:
  infer:
    runs-on: ubuntu-latest
    steps:
      - name: Scan items and summarize select/user/date fields
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          LIST_ID: ${{ inputs.list_id }}
          LIMIT: ${{ inputs.limit }}
        run: |
          set -euo pipefail
          python3 - << 'PY'
          import os, json, urllib.request, collections

          token = os.environ["SLACK_BOT_TOKEN"]
          list_id = os.environ["LIST_ID"]
          limit = int(os.environ.get("LIMIT","30"))
          limit = max(1, min(50, limit))

          def post(method: str, payload: dict):
              url = f"https://slack.com/api/{method}"
              data = json.dumps(payload).encode("utf-8")
              req = urllib.request.Request(url, data=data, method="POST")
              req.add_header("Authorization", f"Bearer {token}")
              req.add_header("Content-Type", "application/json; charset=utf-8")
              with urllib.request.urlopen(req, timeout=30) as resp:
                  return json.loads(resp.read().decode("utf-8"))

          res = post("slackLists.items.list", {"list_id": list_id, "limit": limit})
          if not res.get("ok"):
              raise RuntimeError(res)

          items = res.get("items", [])
          print(f"items_scanned={len(items)}")
          print()

          # column_id -> info
          select_opts = collections.defaultdict(set)
          user_cols = collections.defaultdict(int)
          date_cols = collections.defaultdict(int)
          text_cols = collections.defaultdict(int)

          for it in items:
              for f in it.get("fields", []):
                  col = f.get("column_id") or f.get("key")
                  if "select" in f and isinstance(f.get("select"), list):
                      for opt in f["select"]:
                          select_opts[col].add(opt)
                  if "user" in f and isinstance(f.get("user"), list) and f["user"]:
                      user_cols[col] += 1
                  if "date" in f and isinstance(f.get("date"), list) and f["date"]:
                      date_cols[col] += 1
                  if f.get("key") == "name" or "rich_text" in f:
                      text_cols[col] += 1

          print("=== SELECT COLUMNS (column_id -> option_ids) ===")
          out = {k: sorted(list(v)) for k, v in select_opts.items()}
          print(json.dumps(out, ensure_ascii=False, indent=2))
          print()

          print("=== USER COLUMNS (column_id -> nonempty_count) ===")
          print(json.dumps(user_cols, ensure_ascii=False, indent=2))
          print()

          print("=== DATE COLUMNS (column_id -> nonempty_count) ===")
          print(json.dumps(date_cols, ensure_ascii=False, indent=2))
          print()

          print("=== TEXT-ish COLUMNS (column_id -> count) ===")
          print(json.dumps(text_cols, ensure_ascii=False, indent=2))
          PY
